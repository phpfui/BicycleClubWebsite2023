# Website Architecture
The project uses an MVC approach, but objects are required to handle any results from request to the server.

### Directory Structure
All directories starting with an uppercase character are namespaces containing PHP code only (a few exceptions exist where a package namespace violates PHP best practice.  The following are dedicated directories and their usage:
* .githooks - contains repository specific git hooks.
* .github - contains github actions and configuration.
* backups - contains database backups.  Ideally these backups are transferred off the machine on a regular basis.
* config - contains setting files for the database and other things not storable in the database.
* conversions - contains example conversion and other scripts.  Some may be outdated.
* data - temp directory of one of the libraries used.
* docs - contains this and other documentation.
* files - contains user uploaded files needed by the website.  Should be backed up on another machine.
* import - contains files that are being imported.
* oneOffScripts - contains php scripts that have been useful in the past.
* scss - contains scss files needed to generate the css files the website uses.
* session - contains session files generated by PHP.
* tmp - temp directory for mpdf
* ttfonts - true type fonts used by some libraries.
* unused - files no longer needed but may be needed in the future.
* vendor - used by composer and .gitignored

### www (public) Directory Structure
The **www** directory is the public directory and has the following user directories that should be backed up.

* images - various types of uploaded images
* pdf - [Administration Files](/Admin/files)
* video - [Uploaded Video Files](/Video/all)

Other files are part of the site and managed by git with the exception of [favicon](/System/Settings/favIcon) files

### App namespace
All website logic is in the [App](/System/docs?n=App) namespace. Other directories from the project root are third party libraries and should be maintained via the **update.php** script in the project root directory.

### Supply Chain Security
Since all third party PHP code is checked into git, all updates are reviewed by hand to insure supply chain integrity. Blind use of Composer on deploy is a major security threat.

### Naming Conventions
This project does **NOT** use the ***use*** statement unless needed for a closure. Use statements obfuscate the code and add to run time overhead.  Please use Fully Qualified Names (FQN) everywhere.

Namespaces should be as short as possible and generally singular. Most cases don't require namespaces deeper than 3 levels and a class name.  Do not put words in the class name that should be in the namespace!  For example, MemberModel is a bad class name.  It should be in the Model namespace and simply named Member. MemberView is also a bad class name for the same reason.  Both classes should be named Member. Since FQN will instantly show you the type of the class, so there is no need to add it to the class name. Identical class names are encouraged in different namespaces. This allows for easy identification of potential usable classes and can be leveraged to provide matching functionality across wide sections of code.

All of the custom project code should be in the App base namespace. Do not add application specific code outside the App namespace.

### Autoloading
While Composer generates autoloading files, they are slow and consume memory. The project maps the namespace and class name directly to the file system and includes the file. This is the absolutely fastest autoloader with no memory footprint.  The best way to update the dependencies in the project is to run the **update.php** file from the project root.  It should map all required libraries into the project correctly.

Because the linux file system is case sensitive, directory and php file names are CASE SENSITIVE!

### Controllers
All controllers are in the [App\WWW](/System/docs?n=App\WWW) namespace.  This namespace corresponds to the public directory of www from the project root.

This project uses the [PHPFUI\NanoController](/System/docs?n=PHPFUI&c=NanoController) to map the [App\WWW](/System/docs?n=App\WWW) class hierarchy directly to URIs.

As with other MVC frameworks, the job of a controller to is process the request. Basically, get the requested data, pass it to the requested view and return the results from the view.

Ideally data is retrieved from existing models, and passed to existing views. Occasionally data is a one off and directly fetched by the controller. Any data required in two or more places should be placed in a model.  Simple database requests should be done with the [App\Table](/System/docs?n=App\Table) classes.  Same for views.  Trivial view logic is sometimes placed in the controller, but most views are in the [App\View](/System/docs?n=App\View) namespace.  Some good examples of one off data and views are in the [App\WWW\System](/System/docs?n=App\WWW&c=System) class.

### Cron Controller
The project supports Cron jobs in the [App\Cron\Job](/System/docs?n=App\Cron\Job) namespace.  To add a new cron job, just inherit from the [App\Cron\BaseJob](/System/docs?n=App\Cron&c=BaseJob) class and place it in the **App/Cron/Job** directory.  You will need to implement the following three methods:

* **description : string** describing what the cron job does (single line short descriptions please)
* **willRun : boolean** returns true if it should run at the time specified by [App\Cron\Controller](/System/docs?n=App\Cron&c=Controller).
* **run : void** actually does the work and will be called when needed.

Cron jobs are generally run every 5 minutes (to avoid server load), but can be run at any interval your system supports.

### Models
Intensive business logic should be in the [App\Model](/System/docs?n=App\Model) namespace. Simple query logic should be placed in the [App\Table](/System/docs?n=App\Table) namespace with the corresponding table that makes the most sense.

Models should only accept data and return data and not views or manipulated HTML.

### Models and SQL commands
All SQL **MUST** live in either [App\Table](/System/docs?n=App\Table) or [App\Record](/System/docs?n=App\Record) namespaces.  SQL in any other namespace will not be allowed.  Direct SQL is NOT allowed in the [App\Model](/System/docs?n=App\Model) namespace, use [App\Table](/System/docs?n=App\Table) and [App\Record](/System/docs?n=App\Record) classes instead.

### Record namespace
All database tables have a corresponding [App\Record](/System/docs?n=App\Record) and [App\Table](/System/docs?n=App\Table) class. The [App\Record](/System/docs?n=App\Record) namespace represents an individual typed record in a Table.  The [App\Table](/System/docs?n=App\Table) namespace is how you deal with a collection of records.

### View namespace
This project **DOES NOT ALLOW** hand written HTML with the exception of simple formatting in text to be displayed to users.  Acceptable HTML tags include would include b, i, em, strong and possibly span, etc. Tags like ul, ol or even fieldset should use the [PHPFUI](http://www.phpfui.com) or local [App\View](/System/docs?n=App\View) classes to provide a consistent interface to the user.

All views must be constructed in an object oriented approach with the [PHPFUI](http://www.phpfui.com) library or [App\View](/System/docs?n=App\View) components built from the [PHPFUI](http://www.phpfui.com) library.  Any commonly used view construct that is not covered by [PHPFUI](http://www.phpfui.com) should be created in the [App\UI](/System/docs?n=App\UI) namespace.

The use of the inline style attributes should be avoided where ever possible.  Use of standard classes is encouraged.

Additional View namespaces are recommended when you have more than one view in a related section of the website, but view classes that do more than one thing are OK as well.

See [Website Philosophy](Philosophy.md) for more details on view architecture.

### Report and other namespaces
Additional namespaces should be created to help organize the code.  Report is a good example.

### Deployment
Deployment is handled by a git checkout command run on the server. Everything that needs to be deployed must be checked into git in a deployment ready state. File manipulation (deleting cache files and such) can also be done at deployment.  Also service restarts and other similar things can be done at deployment, but no code compilation or other processing is allowed.  More complex needs can be done with Migrations.  Migrations are run after the code is deployed.

### Migrations
Migrations are done by adding a numbered migration class into the [\App\DB\Migration](/System/docs?n=App\DB\Migration) directory. The next available migration number must be used for new migrations.  Migrations need to both run up and down successfully.  Migrations are atomic and each migration is run before the next higher migration.  They can also be rolled back one at a time. The database records the migration number and the time it was run. Migrations happen after each deploy automatically.

### git Hooks
You should enable git hooks by executing the following command:
~~~
git config core.hooksPath .githooks
~~~
The .githooks directory will contain all the correct hooks checked into the repository.

### Pull Requests
Pull requests should conform to code style standards as enforced by PHP-CS-Fixer and explain the reason for change. Unit tests are recommended when possible.

### Code Style
Code style is automatically done on git check in if git hooks have been configured properly.

### PHPStan
The project uses PHPStan. **vendor/bin/phpstan** should produce no errors or warnings.

### PHPUnit
The project uses PHPUnit testing. **vendor/bin/phpunit** should produce no errors or warnings. When adding new code, unit tests are encouraged.
